<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MDI â€¢ Roue Loto V6.5 (TÃ©lÃ©commande)</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@800;900&display=swap" rel="stylesheet">

  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>

  <style>
    :root {
      --wheel-size: 820px;
      --wheel-stroke: 16px;
      --wheel-text-size: 30px;
      --wheel-text-weight: 900;
      --pointer-side: "left";
      --pointer-size: 34px;
      --pointer-color: #ffffff;
      --pointer-rotate-180: "on";
      --pointer-overlap: 0.86;
      --spin-direction: "cw";
      --winner-confetti: "on";
      --confetti-density: 180;
      --confetti-duration-ms: 2200;
      --label-rotate-180: "off";
      --max-participants: 48;
    }

    html, body {
      background-color: transparent;
      margin: 0; padding: 0; overflow: hidden;
      height: 100vh; width: 100vw;
      font-family: 'Montserrat', sans-serif;
    }

    .hidden { display: none !important; }

    #security-screen {
      width: 100%; height: 100%;
      display: flex; align-items: center; justify-content: center;
      flex-direction: column;
      background: rgba(0,0,0,0);
      color: #ff3b30;
      z-index: 1000;
      position: absolute;
      text-shadow: 0 3px 18px rgba(0,0,0,0.9);
    }
    .security-x {
      font-size: 84px;
      font-weight: 900;
      color: #ff3b30;
    }
    .security-text {
      font-size: 34px;
      font-weight: 900;
      text-align: center;
      color: #ff3b30;
    }

    #app {
      display: grid;
      place-items: center;
      width: 100vw;
      height: 100vh;
      position: relative;
    }

    .stage {
      position: relative;
      width: var(--wheel-size);
      height: var(--wheel-size);
    }

    canvas#wheel {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
    }

    .pointer {
      position: absolute;
      top: 50%;
      z-index: 100;
      width: 0; height: 0;
      border-style: solid;
      transform: translateY(-50%);
    }

    [data-pointer-side="left"] .pointer {
      left: calc(-1 * var(--pointer-size) * var(--pointer-overlap));
      border-width: var(--pointer-size) var(--pointer-size) var(--pointer-size) 0;
      border-color: transparent var(--pointer-color) transparent transparent;
    }

    [data-pointer-side="right"] .pointer {
      right: calc(-1 * var(--pointer-size) * var(--pointer-overlap));
      border-width: var(--pointer-size) 0 var(--pointer-size) var(--pointer-size);
      border-color: transparent transparent transparent var(--pointer-color);
    }

    .mdi-pointer-flip .pointer {
      transform: translateY(-50%) rotate(180deg);
    }

    .winner {
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      z-index: 200;
      display: none;
    }

    .mdi-show-winner .winner {
      display: block;
      animation: winnerPop 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }

    @keyframes winnerPop {
      0% { transform: translate(-50%, -50%) scale(0.3); opacity: 0; }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }

    .winner-panel {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 40px 60px;
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
      text-align: center;
    }

    .winner-name {
      font-size: 48px;
      font-weight: 900;
      color: white;
      text-shadow: 0 4px 12px rgba(0,0,0,0.3);
      display: block;
    }

    canvas.confetti {
      position: fixed;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      pointer-events: none;
      z-index: 150;
      display: none;
    }

    .mdi-confetti canvas.confetti {
      display: block;
    }
  </style>
</head>

<body>
  <div id="security-screen" class="hidden">
    <div class="security-x">âœ–</div>
    <div class="security-text">ACCÃˆS REFUSÃ‰ / ACCESS DENIED</div>
  </div>

  <div id="app" class="hidden">
    <div class="stage">
      <canvas id="wheel"></canvas>
      <div class="pointer"></div>

      <div id="winner" class="winner">
        <div class="winner-panel">
          <span id="winnerName" class="winner-name"></span>
        </div>
      </div>
    </div>

    <canvas id="confetti" class="confetti"></canvas>
  </div>

  <script>
    /**
     * ============================================================
     * MDI ROUE LOTO - V6.5 (TÃ‰LÃ‰COMMANDE)
     * ============================================================
     * âœ… PilotÃ© uniquement par tÃ©lÃ©commande (plus de triggers chat)
     * âœ… Design original conservÃ©
     * âœ… Confettis gagnant
     * âœ… Masquage/affichage automatique
     * ============================================================
     */

    const SERVER_URL = "https://magic-digital-impact-live.onrender.com";
    const OVERLAY_TYPE = "roue_loto";

    function cssVar(name, fallback = "") {
      const v = getComputedStyle(document.documentElement).getPropertyValue(name);
      return v ? v.trim().replace(/^['"]+|['"]+$/g, "") : fallback;
    }
    function cssNum(name, fallback) {
      const n = Number(cssVar(name, ""));
      return Number.isFinite(n) ? n : fallback;
    }
    function cssOnOff(name, fallbackOn = true) {
      const v = (cssVar(name, "") || "").toLowerCase();
      if (!v) return fallbackOn;
      return v === "on" || v === "true" || v === "1";
    }
    function clamp(n, a, b) {
      return Math.max(a, Math.min(b, n));
    }

    const elSecurity = document.getElementById("security-screen");
    const elApp = document.getElementById("app");
    const wheelCanvas = document.getElementById("wheel");
    const wheelCtx = wheelCanvas.getContext("2d");
    const elWinnerName = document.getElementById("winnerName");
    const confettiCanvas = document.getElementById("confetti");
    const confettiCtx = confettiCanvas.getContext("2d");

    let STATE = "idle";
    let participants = [];
    let winnerIndex = -1;
    let wheelAngle = 0;
    let spinning = false;
    let spinStartTs = 0;
    let spinDurationMs = 4200;
    let spinStartAngle = 0;
    let targetAngle = 0;
    let lastSpinAt = 0;

    let spinDirection = "cw";
    let pointerSide = "left";
    let maxParticipants = 48;
    let spinCooldownMs = 1800;

    function readConfig() {
      spinDirection = cssVar("--spin-direction", "cw").toLowerCase();
      spinDirection = (spinDirection === "ccw") ? "ccw" : "cw";

      pointerSide = cssVar("--pointer-side", "left").toLowerCase();
      pointerSide = (pointerSide === "right") ? "right" : "left";
      document.documentElement.setAttribute("data-pointer-side", pointerSide);

      const flip = cssOnOff("--pointer-rotate-180", true);
      document.documentElement.classList.toggle("mdi-pointer-flip", !!flip);

      maxParticipants = clamp(cssNum("--max-participants", 48), 4, 200);
      spinCooldownMs = clamp(cssNum("--spin-cooldown-ms", 1800), 500, 12000);
    }

    const basePalette = [
      "#2ecc71","#e74c3c","#3b82f6","#f1c40f",
      "#9b59b6","#1abc9c","#e67e22","#ec4899",
      "#22c55e","#ef4444","#60a5fa","#f59e0b"
    ];

    function resizeWheelCanvas() {
      const cssSize = cssNum("--wheel-size", 820);
      const dpr = Math.max(1, window.devicePixelRatio || 1);

      wheelCanvas.style.width = cssSize + "px";
      wheelCanvas.style.height = cssSize + "px";
      wheelCanvas.width = Math.floor(cssSize * dpr);
      wheelCanvas.height = Math.floor(cssSize * dpr);

      wheelCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
      drawWheel();
    }

    function drawWheel() {
      const cssSize = cssNum("--wheel-size", 820);
      const stroke = cssNum("--wheel-stroke", 16);
      const textSize = cssNum("--wheel-text-size", 30);
      const textWeight = cssNum("--wheel-text-weight", 900);

      const W = cssSize, H = cssSize;
      const cx = W/2, cy = H/2;
      const r = (W/2) - stroke - 6;

      wheelCtx.clearRect(0, 0, W, H);

      wheelCtx.save();
      wheelCtx.translate(cx, cy);
      wheelCtx.rotate(wheelAngle);

      if (participants.length === 0) {
        wheelCtx.beginPath();
        wheelCtx.arc(0, 0, r, 0, Math.PI*2);
        wheelCtx.fillStyle = "rgba(10,15,30,0.65)";
        wheelCtx.fill();
        wheelCtx.lineWidth = stroke;
        wheelCtx.strokeStyle = "rgba(255,255,255,0.18)";
        wheelCtx.stroke();
        wheelCtx.restore();
        return;
      }

      const n = participants.length;
      const slice = (Math.PI*2) / n;

      for (let i = 0; i < n; i++) {
        const a0 = i * slice;
        const a1 = a0 + slice;

        wheelCtx.beginPath();
        wheelCtx.moveTo(0, 0);
        wheelCtx.arc(0, 0, r, a0, a1);
        wheelCtx.closePath();

        wheelCtx.fillStyle = basePalette[i % basePalette.length];
        wheelCtx.fill();

        if (i === winnerIndex) {
          wheelCtx.save();
          wheelCtx.shadowColor = "rgba(255,255,255,0.65)";
          wheelCtx.shadowBlur = 22;
          wheelCtx.lineWidth = 10;
          wheelCtx.strokeStyle = "rgba(255,255,255,0.85)";
          wheelCtx.stroke();
          wheelCtx.restore();
        } else {
          wheelCtx.lineWidth = 2;
          wheelCtx.strokeStyle = "rgba(0,0,0,0.18)";
          wheelCtx.stroke();
        }

        const label = participants[i].name || participants[i];
        const mid = a0 + slice/2;

        wheelCtx.save();
        wheelCtx.rotate(mid);

        wheelCtx.fillStyle = "rgba(255,255,255,0.96)";
        wheelCtx.font = `${textWeight} ${textSize}px Montserrat, sans-serif`;
        wheelCtx.textBaseline = "middle";
        wheelCtx.lineWidth = 4;
        wheelCtx.strokeStyle = "rgba(0,0,0,0.35)";

        const maxChars = 14;
        const safeLabel = String(label).length > maxChars ? (String(label).slice(0, maxChars-1) + "â€¦") : label;

        const tx = Math.max(120, r*0.26);

        const flipLabel = cssOnOff("--label-rotate-180", false);
        if (flipLabel) {
          wheelCtx.rotate(Math.PI);
          wheelCtx.textAlign = "right";
          wheelCtx.strokeText(safeLabel, -tx, 0);
          wheelCtx.fillText(safeLabel, -tx, 0);
        } else {
          wheelCtx.textAlign = "left";
          wheelCtx.strokeText(safeLabel, tx, 0);
          wheelCtx.fillText(safeLabel, tx, 0);
        }

        wheelCtx.restore();
      }

      wheelCtx.beginPath();
      wheelCtx.arc(0, 0, r, 0, Math.PI*2);
      wheelCtx.lineWidth = stroke;
      wheelCtx.strokeStyle = "rgba(255,255,255,0.22)";
      wheelCtx.stroke();

      wheelCtx.restore();
    }

    let confetti = [];
    let confettiEndTs = 0;

    function resizeConfetti() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      confettiCanvas.width = Math.floor(window.innerWidth * dpr);
      confettiCanvas.height = Math.floor(window.innerHeight * dpr);
      confettiCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    function rand01() {
      const u = new Uint32Array(1);
      crypto.getRandomValues(u);
      return u[0] / 0xFFFFFFFF;
    }

    function startConfetti() {
      if (!cssOnOff("--winner-confetti", true)) return;

      document.documentElement.classList.add("mdi-confetti");
      resizeConfetti();

      const density = clamp(cssNum("--confetti-density", 180), 30, 600);
      const dur = clamp(cssNum("--confetti-duration-ms", 2200), 600, 8000);

      confetti = [];
      confettiEndTs = performance.now() + dur;

      for (let i = 0; i < density; i++) {
        const x = rand01() * window.innerWidth;
        const y = -20 - rand01()*200;
        const s = 6 + rand01()*10;
        const vx = (rand01()-0.5)*2.2;
        const vy = 2.0 + rand01()*4.5;
        const rot = rand01()*Math.PI*2;
        const vr = (rand01()-0.5)*0.25;
        const col = basePalette[i % basePalette.length];
        confetti.push({x, y, s, vx, vy, rot, vr, col});
      }
      requestAnimationFrame(tickConfetti);
    }

    function tickConfetti(ts) {
      confettiCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);
      if (ts >= confettiEndTs) {
        document.documentElement.classList.remove("mdi-confetti");
        confetti = [];
        return;
      }
      for (const p of confetti) {
        p.x += p.vx * 3.2;
        p.y += p.vy * 3.6;
        p.rot += p.vr;
        const t = (confettiEndTs - ts) / 500;
        const alpha = clamp(t, 0, 1);

        confettiCtx.save();
        confettiCtx.translate(p.x, p.y);
        confettiCtx.rotate(p.rot);
        confettiCtx.globalAlpha = alpha;
        confettiCtx.fillStyle = p.col;
        confettiCtx.fillRect(-p.s/2, -p.s/2, p.s, p.s*0.7);
        confettiCtx.restore();
      }
      requestAnimationFrame(tickConfetti);
    }

    function normalizeText(raw) {
      let t = String(raw || "");
      t = t.replace(/\u00A0/g, " ").replace(/\s+/g, " ").trim();
      return t;
    }

    function keyOfName(name) {
      return normalizeText(name).toLowerCase();
    }

    function normalizeAngle(a) {
      let x = a % (Math.PI*2);
      if (x < 0) x += Math.PI*2;
      return x;
    }

    function pickRandomIndex(n) {
      const u = new Uint32Array(1);
      crypto.getRandomValues(u);
      return u[0] % n;
    }

    function pointerTargetAngle() {
      return (pointerSide === "left") ? Math.PI : 0;
    }

    function spin() {
      const now = Date.now();
      if (spinning) return;
      if (STATE !== "ready") return;
      if (participants.length < 2) return;
      if (now - lastSpinAt < spinCooldownMs) return;

      lastSpinAt = now;
      spinning = true;
      STATE = "spinning";

      const n = participants.length;
      const selected = pickRandomIndex(n);
      const slice = (Math.PI*2) / n;
      const selectedCenter = selected * slice + slice/2;

      const pointerAngle = pointerTargetAngle();
      const desired = pointerAngle - selectedCenter;

      const extraTurns = 6 + Math.floor(rand01()*4);
      const extra = extraTurns * Math.PI*2;

      const dir = (spinDirection === "cw") ? +1 : -1;

      spinStartAngle = wheelAngle;
      targetAngle = desired + dir * extra;
      spinDurationMs = clamp(3800 + Math.floor(rand01()*2200), 3400, 6500);
      spinStartTs = performance.now();

      requestAnimationFrame(tickSpin);

      function tickSpin(ts) {
        const t = clamp((ts - spinStartTs) / spinDurationMs, 0, 1);
        const e = 1 - Math.pow(1 - t, 3);

        wheelAngle = spinStartAngle + (targetAngle - spinStartAngle) * e;
        drawWheel();

        if (t < 1) {
          requestAnimationFrame(tickSpin);
          return;
        }

        spinning = false;

        const ang = normalizeAngle(pointerAngle - wheelAngle);
        const idx = Math.floor(ang / slice) % n;
        winnerIndex = (idx + n) % n;

        drawWheel();
        const winnerName = participants[winnerIndex]?.name || participants[winnerIndex] || "";
        elWinnerName.textContent = winnerName;
        document.documentElement.classList.add("mdi-show-winner");
        STATE = "winner";
        startConfetti();
      }
    }

    function hideWinner() {
      document.documentElement.classList.remove("mdi-show-winner");
      elWinnerName.textContent = "";
      winnerIndex = -1;
    }

    function clearAll() {
      participants = [];
      winnerIndex = -1;
      spinning = false;
      wheelAngle = 0;
      STATE = "idle";
      hideWinner();
      drawWheel();
    }

    const socket = io(SERVER_URL, {
      transports: ["websocket", "polling"],
      reconnection: true
    });

    socket.on("connect", () => {
      console.log("âœ… [ROUE] ConnectÃ©");
    });

    socket.on("overlay:state", (payload) => {
      if (payload.overlay !== OVERLAY_TYPE) return;

      console.log("ðŸ“¡ [ROUE] Ã‰tat:", payload.state);

      if (payload.state === "idle") {
        elApp.classList.add("hidden");
        clearAll();
        return;
      }

      if (payload.state === "active") {
        elSecurity.classList.add("hidden");
        elApp.classList.remove("hidden");
        STATE = "idle";
      }
    });

    socket.on("roue:start_collect", () => {
      console.log("ðŸ“ [ROUE] DÃ©marrage collecte");
      clearAll();
      STATE = "collecting";
    });

    socket.on("roue:stop_collect", () => {
      console.log("ðŸ”’ [ROUE] Fermeture collecte");
      if (STATE === "collecting") STATE = "ready";
    });

    socket.on("roue:spin", () => {
      console.log("ðŸŽ¡ [ROUE] SPIN");
      spin();
    });

    socket.on("roue:reset", () => {
      console.log("ðŸ”„ [ROUE] Reset");
      clearAll();
    });

    socket.on("roue:participant_added", (data) => {
      if (STATE === "collecting" && data.name) {
        const name = normalizeText(data.name);
        const key = keyOfName(name);
        
        if (!participants.some(p => {
          const pName = p.name || p;
          return keyOfName(pName) === key;
        })) {
          if (participants.length < maxParticipants) {
            participants.push({ name, key });
            drawWheel();
            console.log(`âž• [ROUE] Participant: ${name}`);
          }
        }
      }
    });

    socket.on("raw_vote", (data) => {
      if (!data || !data.vote) return;
      if (STATE !== "collecting") return;

      const name = normalizeText(data.vote);
      const key = keyOfName(name);

      if (!name) return;
      if (participants.length >= maxParticipants) return;

      if (!participants.some(p => {
        const pName = p.name || p;
        return keyOfName(pName) === key;
      })) {
        participants.push({ name, key });
        drawWheel();
        console.log(`âž• [ROUE] Participant (chat): ${name}`);
      }
    });

    socket.on("overlay:forbidden", () => {
      console.error("âŒ [ROUE] AccÃ¨s refusÃ©");
      elSecurity.classList.remove("hidden");
      elApp.classList.add("hidden");
    });

    async function init() {
      await new Promise(resolve => setTimeout(resolve, 800));

      const authMode = cssVar("--auth-mode", "strict");
      const room = cssVar("--room-id", "").trim();
      const key = cssVar("--room-key", "").trim();

      readConfig();
      resizeWheelCanvas();
      resizeConfetti();

      console.log(`ðŸ” [ROUE] Auth: ${authMode}, Room: ${room}`);

      if (!room) {
        console.error("âŒ [ROUE] Aucun room-id");
        elSecurity.classList.remove("hidden");
        return;
      }

      if (authMode === "strict") {
        if (!key) {
          console.error("âŒ [ROUE] Mode strict sans key");
          elSecurity.classList.remove("hidden");
          return;
        }
        socket.emit("overlay:join", { room, key, overlay: OVERLAY_TYPE });
      } else {
        socket.emit("overlay:join", { room, key: "", overlay: OVERLAY_TYPE });
      }

      socket.emit("rejoindre_salle", room);

      console.log("âœ… [ROUE] Init terminÃ©e");
    }

    socket.on("connect", init);

    window.addEventListener("resize", () => {
      resizeWheelCanvas();
      resizeConfetti();
    });

    drawWheel();
  </script>
</body>
</html>
