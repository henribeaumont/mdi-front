<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>MDI Nuage - V6.4 (√âtat Unifi√© + Anti-Collision)</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700;900&display=swap" rel="stylesheet">
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
  
  <style>
    html, body {
      background-color: transparent;
      margin: 0; padding: 0; overflow: hidden;
      height: 100vh; width: 100vw;
      font-family: 'Montserrat', sans-serif;
    }

    .hidden { display: none !important; }

    /* √âcran s√©curit√© */
    .mdi-security {
      width: 100%; height: 100%;
      display: flex; align-items: center; justify-content: center;
      flex-direction: column;
      background: rgba(0,0,0,0);
      color: #ff3b30;
      z-index: 1000;
      position: absolute;
      text-shadow: 0 3px 18px rgba(0,0,0,0.9);
    }
    .mdi-security .mdi-x {
      font-size: 84px;
      font-weight: 900;
      color: #ff3b30;
    }
    .mdi-security .mdi-msg {
      font-size: 34px;
      font-weight: 900;
      text-align: center;
      color: #ff3b30;
    }

    /* Conteneur nuage */
    #cloud-container {
      position: absolute;
      right: var(--cloud-right, 50px);
      top: 50%;
      transform: translateY(-50%);
      width: var(--cloud-width, 650px);
      height: var(--cloud-height, 850px);
      background-color: rgba(88, 88, 88, 0);
      overflow: hidden;
      transition: opacity 0.6s ease-in-out;
    }

    #word-zone { width: 100%; height: 100%; position: relative; }

    #measure-zone {
      position: absolute; top: -9999px; left: -9999px;
      visibility: hidden; white-space: nowrap;
      font-weight: 900; line-height: 1;
      font-family: 'Montserrat', sans-serif;
    }

    .mot {
      position: absolute;
      line-height: 1;
      white-space: nowrap;
      font-weight: 900;
      transition: left 0.6s cubic-bezier(0.19, 1, 0.22, 1),
                  top 0.6s cubic-bezier(0.19, 1, 0.22, 1),
                  font-size 0.6s cubic-bezier(0.19, 1, 0.22, 1),
                  transform 0.6s cubic-bezier(0.19, 1, 0.22, 1),
                  opacity 0.45s ease;
      transform: translate(-50%, -50%);
      -webkit-text-stroke: 1.5px rgba(0, 0, 0, 0.85);
      paint-order: stroke fill;
      filter: drop-shadow(3px 3px 0px rgba(0, 0, 0, 0.2));
      will-change: left, top, font-size, transform, opacity;
      user-select: none;
      z-index: 10;
    }

    .mot.is-new {
      opacity: 0;
      transform: translate(-50%, -50%) scale(0.92);
    }
    .mot.is-new.mdi-in {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }
  </style>
</head>
<body>
  <div id="security-screen" class="mdi-security hidden">
    <div class="mdi-x">‚úñ</div>
    <div class="mdi-msg">ACC√àS REFUS√â / ACCESS DENIED</div>
  </div>

  <div id="cloud-container" class="hidden">
    <div id="word-zone"></div>
  </div>

  <div id="measure-zone"></div>

  <script>
    /**
     * ============================================================
     * MDI NUAGE DE MOTS - V6.4 (√âTAT UNIFI√â + ANTI-COLLISION)
     * ============================================================
     * ‚úÖ Anti-collision : d√©tection chevauchements + r√©organisation
     * ‚úÖ Anti-troncage : vigilance d√©bordements
     * ‚úÖ Option majuscules CSS
     * ‚úÖ Taille de base conserv√©e (70px)
     * ============================================================
     */

    const SERVER_URL = "https://magic-digital-impact-live.onrender.com";
    const OVERLAY_TYPE = "nuage_de_mots";

    // --- UTILITAIRES CSS ---
    function cssVar(name, fallback = "") {
      const v = getComputedStyle(document.documentElement).getPropertyValue(name);
      return v ? v.trim().replace(/^['"]+|['"]+$/g, "") : fallback;
    }
    function cssOnOff(name, fallbackOn = true) {
      const v = (cssVar(name, "") || "").toLowerCase();
      if (!v) return fallbackOn;
      return v === "on" || v === "true" || v === "1";
    }

    // --- √âL√âMENTS DOM ---
    const zone = document.getElementById("word-zone");
    const container = document.getElementById("cloud-container");
    const securityScreen = document.getElementById("security-screen");
    const measureZone = document.getElementById("measure-zone");

    // --- √âTAT ---
    let STATE = "idle";
    let dbMots = {};
    let globalColorIndex = 0;
    let wordPositions = []; // [{x, y, width, height, element}]

    // --- PALETTE ---
    function getPalette() {
      return [
        cssVar("--color-1", "#F054A2"),
        cssVar("--color-2", "#2ecc71"),
        cssVar("--color-3", "#F9AD48"),
        cssVar("--color-4", "#3b82f6"),
        cssVar("--color-5", "#ffffff")
      ];
    }

    // --- RESET ---
    function resetEcran() {
      zone.innerHTML = "";
      dbMots = {};
      globalColorIndex = 0;
      wordPositions = [];
      console.log("üîÑ [NUAGE] Reset complet");
    }

    // --- MESURE TEXTE ---
    function measureText(text, fontSize) {
      measureZone.style.fontSize = fontSize + "px";
      measureZone.textContent = text;
      return {
        width: measureZone.offsetWidth,
        height: measureZone.offsetHeight
      };
    }

    // --- D√âTECTION COLLISION ---
    function hasCollision(x, y, width, height) {
      const margin = 10; // Marge de s√©curit√©
      
      for (const pos of wordPositions) {
        const overlapX = !(x + width + margin < pos.x || x > pos.x + pos.width + margin);
        const overlapY = !(y + height + margin < pos.y || y > pos.y + pos.height + margin);
        
        if (overlapX && overlapY) {
          return true;
        }
      }
      return false;
    }

    // --- TROUVER POSITION LIBRE ---
    function findFreePosition(width, height) {
      const W = container.clientWidth;
      const H = container.clientHeight;
      const cx = W / 2;
      const cy = H / 2;

      // Tentatives en spirale
      const maxAttempts = 500;
      let angle = 0;
      let radius = 0;
      const radiusStep = 15;
      const angleStep = 0.5;

      for (let i = 0; i < maxAttempts; i++) {
        const x = cx + Math.cos(angle) * radius;
        const y = cy + Math.sin(angle) * radius;

        // V√©rifier si dans les limites
        if (x >= 0 && x + width <= W && y >= 0 && y + height <= H) {
          // V√©rifier collision
          if (!hasCollision(x, y, width, height)) {
            return { x, y };
          }
        }

        // Spirale
        angle += angleStep;
        radius += radiusStep * (angle / (Math.PI * 2));
      }

      // Fallback : position al√©atoire
      return {
        x: Math.random() * (W - width),
        y: Math.random() * (H - height)
      };
    }

    // --- RENDU ---
    function render() {
      const W = container.clientWidth;
      const H = container.clientHeight;
      const words = Object.values(dbMots);
      const uppercase = cssOnOff("--uppercase", false);

      // Tri par count d√©croissant
      words.sort((a, b) => b.count - a.count);

      wordPositions = [];

      words.forEach((mot, i) => {
        const displayText = uppercase ? mot.text.toUpperCase() : mot.text;
        let el = document.getElementById(`mot-${mot.text.replace(/\s+/g, '-')}`);
        
        // Taille dynamique
        const baseSize = 70;
        const sizeDecrease = i * 2;
        const countBonus = (mot.count - 1) * 5;
        const fontSize = Math.max(20, baseSize - sizeDecrease + countBonus);

        // Mesurer
        const { width, height } = measureText(displayText, fontSize);

        // Nouvelle cr√©ation
        if (!el) {
          el = document.createElement("div");
          el.id = `mot-${mot.text.replace(/\s+/g, '-')}`;
          el.className = "mot is-new";
          el.style.color = mot.color;
          el.style.fontSize = `${fontSize}px`;
          zone.appendChild(el);

          // Trigger animation
          requestAnimationFrame(() => {
            el.classList.add("mdi-in");
          });
        } else {
          // Mise √† jour
          el.style.fontSize = `${fontSize}px`;
        }

        el.textContent = displayText;

        // Trouver position libre
        const pos = findFreePosition(width, height);
        
        el.style.left = `${pos.x + width/2}px`;
        el.style.top = `${pos.y + height/2}px`;

        // Enregistrer position
        wordPositions.push({
          x: pos.x,
          y: pos.y,
          width,
          height,
          element: el
        });
      });
    }

    // --- SOCKET ---
    const socket = io(SERVER_URL, { 
      transports: ["websocket", "polling"],
      reconnection: true
    });

    socket.on("connect", () => {
      console.log("‚úÖ [NUAGE] Connect√©");
    });

    socket.on("connect_error", (err) => {
      console.warn("‚ö†Ô∏è [NUAGE] Erreur:", err.message);
    });

    // √âtat overlay
    socket.on("overlay:state", (payload) => {
      if (payload.overlay !== OVERLAY_TYPE) return;

      console.log(`üì° [NUAGE] √âtat:`, payload.state, payload.data);

      STATE = payload.state;

      if (STATE === "idle") {
        container.classList.add("hidden");
        resetEcran();
        return;
      }

      if (STATE === "active") {
        securityScreen.classList.add("hidden");
        container.classList.remove("hidden");

        // Synchro serveur
        if (payload.data && payload.data.words) {
          const serverWords = payload.data.words;
          const palette = getPalette();

          dbMots = {};
          Object.keys(serverWords).forEach((key, index) => {
            dbMots[key] = {
              text: key,
              count: serverWords[key],
              color: palette[index % 5]
            };
          });

          globalColorIndex = Object.keys(dbMots).length;
          render();
        }
      }
    });

    socket.on("overlay:forbidden", (payload) => {
      console.error("‚ùå [NUAGE] Acc√®s refus√©:", payload.reason);
      securityScreen.classList.remove("hidden");
      container.classList.add("hidden");
    });

    // Init
    async function init() {
      await new Promise(resolve => setTimeout(resolve, 800));

      const authMode = cssVar("--auth-mode", "strict");
      const room = cssVar("--room-id", "").trim();
      const key = cssVar("--room-key", "").trim();

      console.log(`üîê [NUAGE] Auth: ${authMode}, Room: ${room}`);

      if (!room) {
        console.error("‚ùå [NUAGE] Aucun room-id");
        securityScreen.classList.remove("hidden");
        return;
      }

      if (authMode === "strict") {
        if (!key) {
          console.error("‚ùå [NUAGE] Mode strict sans key");
          securityScreen.classList.remove("hidden");
          return;
        }
        socket.emit("overlay:join", { room, key, overlay: OVERLAY_TYPE });
      } else {
        socket.emit("overlay:join", { room, key: "", overlay: OVERLAY_TYPE });
      }

      console.log("‚úÖ [NUAGE] Auth envoy√©e");
    }

    socket.on("connect", init);
  </script>
</body>
</html>
